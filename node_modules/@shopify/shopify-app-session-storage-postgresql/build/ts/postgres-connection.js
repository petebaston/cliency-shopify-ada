"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PostgresConnection = void 0;
var tslib_1 = require("tslib");
var pg_1 = tslib_1.__importDefault(require("pg"));
var PostgresConnection = /** @class */ (function () {
    function PostgresConnection(dbUrl, sessionStorageIdentifier) {
        this.dbUrl = new URL(dbUrl);
        this.ready = this.init();
        this.sessionStorageIdentifier = sessionStorageIdentifier;
    }
    PostgresConnection.prototype.query = function (query, params) {
        if (params === void 0) { params = []; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.ready];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.pool.query(query, params)];
                    case 2: return [2 /*return*/, (_a.sent()).rows];
                }
            });
        });
    };
    /**
     * Runs a series of queries in a transaction - requires the use of a SINGLE client,
     * hence we can't use the query method above.
     *
     * @param queries an array of SQL queries to execute in a transaction
     */
    PostgresConnection.prototype.transaction = function (queries) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var client, queries_1, queries_1_1, query, e_1_1, error_1;
            var e_1, _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.ready];
                    case 1:
                        _b.sent();
                        // check if the first and last queries are BEGIN and COMMIT, if not, add them
                        if (queries[0] !== 'BEGIN') {
                            queries.unshift('BEGIN');
                        }
                        if (queries[queries.length - 1] !== 'COMMIT') {
                            queries.push('COMMIT');
                        }
                        return [4 /*yield*/, this.pool.connect()];
                    case 2:
                        client = _b.sent();
                        _b.label = 3;
                    case 3:
                        _b.trys.push([3, 12, 14, 15]);
                        _b.label = 4;
                    case 4:
                        _b.trys.push([4, 9, 10, 11]);
                        queries_1 = tslib_1.__values(queries), queries_1_1 = queries_1.next();
                        _b.label = 5;
                    case 5:
                        if (!!queries_1_1.done) return [3 /*break*/, 8];
                        query = queries_1_1.value;
                        return [4 /*yield*/, client.query(query)];
                    case 6:
                        _b.sent();
                        _b.label = 7;
                    case 7:
                        queries_1_1 = queries_1.next();
                        return [3 /*break*/, 5];
                    case 8: return [3 /*break*/, 11];
                    case 9:
                        e_1_1 = _b.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 11];
                    case 10:
                        try {
                            if (queries_1_1 && !queries_1_1.done && (_a = queries_1.return)) _a.call(queries_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 11: return [3 /*break*/, 15];
                    case 12:
                        error_1 = _b.sent();
                        // rollback if any of the queries fail
                        return [4 /*yield*/, client.query("ROLLBACK")];
                    case 13:
                        // rollback if any of the queries fail
                        _b.sent();
                        throw error_1;
                    case 14:
                        client.release();
                        return [7 /*endfinally*/];
                    case 15: return [2 /*return*/];
                }
            });
        });
    };
    PostgresConnection.prototype.disconnect = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: 
                    // Since no longer using individual client, use disconnect to reset the pool.
                    return [4 /*yield*/, this.ready];
                    case 1:
                        // Since no longer using individual client, use disconnect to reset the pool.
                        _a.sent();
                        return [4 /*yield*/, this.pool.end()];
                    case 2:
                        _a.sent();
                        this.ready = this.init();
                        return [2 /*return*/];
                }
            });
        });
    };
    PostgresConnection.prototype.connect = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.ready];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    PostgresConnection.prototype.getDatabase = function () {
        return decodeURIComponent(this.dbUrl.pathname.slice(1));
    };
    PostgresConnection.prototype.hasTable = function (tablename) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var query, rows;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.ready];
                    case 1:
                        _a.sent();
                        query = "\n      SELECT EXISTS (\n        SELECT tablename FROM pg_catalog.pg_tables\n          WHERE tablename = ".concat(this.getArgumentPlaceholder(1), "\n      )\n  ");
                        return [4 /*yield*/, this.query(query, [tablename])];
                    case 2:
                        rows = _a.sent();
                        return [2 /*return*/, rows[0].exists];
                }
            });
        });
    };
    PostgresConnection.prototype.getArgumentPlaceholder = function (position) {
        return "$".concat(position);
    };
    PostgresConnection.prototype.init = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                this.pool = new pg_1.default.Pool({
                    host: this.dbUrl.hostname,
                    user: decodeURIComponent(this.dbUrl.username),
                    password: decodeURIComponent(this.dbUrl.password),
                    database: this.getDatabase(),
                    port: Number(this.dbUrl.port),
                });
                return [2 /*return*/];
            });
        });
    };
    return PostgresConnection;
}());
exports.PostgresConnection = PostgresConnection;
//# sourceMappingURL=postgres-connection.js.map